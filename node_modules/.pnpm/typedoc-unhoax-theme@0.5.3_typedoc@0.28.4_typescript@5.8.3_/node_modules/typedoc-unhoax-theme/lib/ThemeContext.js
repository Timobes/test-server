import { JSX, DefaultThemeRenderContext, ReflectionKind, i18n, } from 'typedoc';
import { SearchIcon } from './icons/search.js';
import { AnchorIcon } from './icons/anchor.js';
import { MenuIcon } from './icons/menu.js';
import { DocumentIcon } from './icons/document.js';
import { ChevronDownIcon } from './icons/chevron-down.js';
import { Navigation, NavTreeItem, NavTreeLeaf } from './components/Navigation.js';
import { Html } from './components/Html.js';
import { PageHeader } from './components/PageHeader.js';
import { SidebarLinks } from './components/SidebarLinks.js';
import { Settings } from './components/Settings.js';
import { Index } from './components/Index.js';
import { MemberSummary } from './components/MemberSummary.js';
import { ReflectionTemplate } from './components/ReflectionTemplate.js';
import { MemberSignatures } from './components/MemberSignatures.js';
import { MemberSignatureBody } from './components/MemberSignatureBody.js';
export class UnhoaxThemeContext extends DefaultThemeRenderContext {
    customIcons = {
        search: SearchIcon,
        anchor: AnchorIcon,
        // checkbox: () => <></>,
        chevronDown: ChevronDownIcon,
        menu: MenuIcon,
        [ReflectionKind.Document]: DocumentIcon,
        // chevronSmall: () => <></>,
        folder: () => JSX.createElement(JSX.Fragment, null, "FOLDER"),
    };
    get icons() {
        return { ...this.theme.icons, ...this.customIcons };
    }
    get projectDisplayName() {
        const { name, packageVersion } = this.page.project;
        const version = packageVersion && `v${packageVersion}`;
        return [name, version].filter(Boolean).join(' – ');
    }
    defaultLayout = (template, props) => {
        return (JSX.createElement(Html, { context: this, template: template, props: props }));
    };
    toolbar = (props) => {
        return JSX.createElement(PageHeader, { context: this });
    };
    // Important: If you use `this`, this function MUST be bound! Template functions
    // are free to destructure the context object to only grab what they care about.
    footer = () => {
        return (JSX.createElement("footer", { class: 'page-footer' },
            this.hook('footer.begin', this),
            JSX.createElement("div", { class: 'footer-content' },
                JSX.createElement("select", { id: 'theme-select' },
                    JSX.createElement("option", { value: 'light' },
                        '☀️',
                        "\u00A0 \u00A0",
                        i18n.theme_light()),
                    JSX.createElement("option", { value: 'dark' },
                        '🌙',
                        "\u00A0 \u00A0",
                        i18n.theme_dark())),
                JSX.createElement("div", null, "TypeDoc \uD83E\uDD13 Unhoax Theme")),
            JSX.createElement("hr", null),
            JSX.createElement("small", { class: 'copyright' },
                JSX.createElement("span", null, "Made with \u2764\uFE0F by SacNoeuds"),
                JSX.createElement("span", null,
                    "Copyright ",
                    new Date().getFullYear())),
            this.hook('footer.end', this)));
    };
    // override hierarchy = (typeHierarchy: DeclarationHierarchy | undefined): JSX.Element | undefined => {
    //   return <div>hierarchy</div>
    // }
    navigation = (props) => {
        return (JSX.createElement(Navigation, { context: this, currentUrl: props.url, props: props }));
    };
    pageNavigation = (props) => {
        const pageHeadings = props.pageHeadings.filter((heading) => heading.text);
        const pageSections = props.pageSections.flatMap((section) => {
            if (!section.title)
                return [];
            const headings = section.headings.filter((heading) => heading.text);
            return headings.length === 0 ? [] : [{ ...section, headings }];
        });
        if (pageHeadings.length + pageSections.length === 0)
            return JSX.createElement(JSX.Fragment, null);
        return (JSX.createElement("div", { class: 'page-nav' },
            JSX.createElement("h4", null, "On This Page"),
            pageSections.length > 0 && (JSX.createElement("ul", { class: 'nav-tree' }, pageSections.map((section) => {
                return (JSX.createElement(NavTreeItem, { text: section.title, defaultOpened: true, children: section.headings.map((heading) => {
                        return (JSX.createElement(NavTreeLeaf, { class: heading.level ? `page-nav-leaf-${heading.level}` : undefined, customIcons: this.customIcons, isActive: false, text: heading.text, link: heading.link, kind: heading.kind }));
                    }) }));
            }))),
            pageSections.length === 0 && pageHeadings.length > 0 && (JSX.createElement("ul", { class: 'nav-tree' }, pageHeadings.map((heading) => {
                return (JSX.createElement(NavTreeLeaf, { customIcons: this.customIcons, isActive: false, text: ['#'.repeat(heading.level ?? 0), heading.text].filter(Boolean).join(' '), link: heading.link, kind: heading.kind }));
            })))));
    };
    sidebarLinks = () => {
        return JSX.createElement(SidebarLinks, { context: this });
    };
    settings = () => {
        return JSX.createElement(Settings, { context: this });
    };
    /** Right sidebar, with settings and "what's on this page" */
    pageSidebar = (props) => {
        return this.pageNavigation(props);
    };
    // override breadcrumb = (props: Reflection): JSX.Element | undefined => {
    //   return <div>Breadcrumb</div>
    // }
    /** Content header */
    header = (props) => {
        // Don't render on the index page or the class hierarchy page
        // We should probably someday render on the class hierarchy page, but currently breadcrumbs
        // are entirely dependent on the reflection hierarchy, so it doesn't make sense today.
        const renderBreadcrumbs = !['index.html', 'hierarchy.html', 'modules.html'].includes(props.url);
        const renderTitle = props.model.kind !== ReflectionKind.Document;
        return (JSX.createElement("div", { class: 'page-content-header' },
            renderBreadcrumbs && JSX.createElement("ul", { class: 'breadcrumb' }, this.breadcrumbs(props.model)),
            renderTitle && JSX.createElement("h1", null, props.model.name)));
    };
    breadcrumbs = (props, isFirst = true) => {
        return (JSX.createElement(JSX.Fragment, null,
            props.parent && this.breadcrumbs(props.parent, false),
            props.parent && JSX.createElement("span", null, "/"),
            JSX.createElement("li", null, !isFirst ? JSX.createElement("a", { href: this.urlTo(props) }, props.name) : JSX.createElement("span", null, props.name))));
    };
    reflectionTemplate = (props) => {
        return (JSX.createElement(ReflectionTemplate, { context: this, props: props }));
    };
    // override hierarchyTemplate = (props: PageEvent<ProjectReflection>): JSX.Element => {
    //   return <div>Hierarchy Template</div>
    // }
    indexTemplate = (props) => {
        return (JSX.createElement("div", { class: 'markdown readme' },
            JSX.createElement(JSX.Raw, { html: this.markdown(props.model.readme || []) })));
    };
    documentTemplate = (props) => {
        return (JSX.createElement("div", { class: 'markdown document' },
            JSX.createElement(JSX.Raw, { html: this.markdown(props.model.content) })));
    };
    index = (props) => {
        return (JSX.createElement(Index, { context: this, props: props }));
    };
    moduleMemberSummary = (member) => {
        return (JSX.createElement(MemberSummary, { context: this, member: member }));
    };
    memberSignatures = (props) => {
        return (JSX.createElement(MemberSignatures, { context: this, props: props }));
    };
    // cannot be overridden because it relies on internals
    // override moduleReflection = (mod: DeclarationReflection | ProjectReflection): JSX.Element => {}
    // cannot be overridden because it relies on internals
    // override memberSignatureTitle = (props: SignatureReflection, options?: { hideName?: boolean } | undefined): JSX.Element => {
    memberSignatureBody = (props, r_1) => {
        return (JSX.createElement(MemberSignatureBody, { context: this, props: props }));
    };
}
